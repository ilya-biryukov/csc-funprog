{-- Домашнее задание № 6. Задача 2. Бирюков Илья, CS Center, отделение SE
 -
 - Написать функцию bigraph :: Graph -> Bool, которая проверяет, является ли заданный
 - связный неориентированный граф двудольным.
 -
 -}


type Graph = (Int, Int -> Int -> Bool)

{--
 - Вспомогательная функция. Выдаёт список вершин графа,смежных с переданной.
 -
 - Аргументы:
 -    n Номер вершины в графе, для которой нужно выдать смежные вершины
 -    graph Сам граф
 -
 - Возвращает:
 -    Список вершин, смежных переданной
 -}
-- Выдаём те вершины, для которых функция проверки существования ребра ответит `да`
adjacentNodes :: Int -> Graph -> [Int]
adjacentNodes n (vs, edgeTest) = filter (\x -> edgeTest n x) [1..vs]


{--
 - Проверяет является ли граф двусвязным поиском в глубину.
 -
 - Аргументы:
 -    redSet Множество ``красных'' вершин графа
 -    blueSet Множество ``синих'' вершин графа
 -    graph Сам Граф
 -    stack Стек из вершин, которые мы ещё не обошли
 -
 - Возвращает:
 -    True, если граф является двудольным
 -    False, в обратном случае
 -}
-- План такой:
--    Проходим поиском в глубину по графу, помечая каждую вершину на стеке ``красным''
--    или ``синим'' цветом. Все соседи помеченной вершины помечаем вторым цветом. Если
--    вдруг находим соседа, который уже помечен тем же цветом, что и наша вершины -
--    значит граф не является двудольным. Если все вершины были успешно покрашены - то
--    граф двудольный.
--
--    Цвет представляет собой булевское значение: True - для красного. False - для синего
--    На стеке хранятся пары (вершины, цвет)
dfsBipartite :: [Int] -> [Int] -> Graph -> [(Int, Bool)] -> Bool
dfsBipartite redSet blueSet graph stack
    -- Если стек пустой, значит все вершины были успешно покрашены
    | null stack = True
    -- Иначе проверим что после покраски соседей не будет конфликтов, добавим их в стек
    -- и продолжим исполнение поиска в глубину
    | otherwise = newNodesAreOk && dfsBipartite newRed newBlue graph newStack
      where
      -- Номер вершины графа, лежащей на вершине стека.
      node = fst $ head stack
      -- Цвет вершины графа, лежащей на вершине стека
      color = snd $ head stack
      -- Список из пар (вершина, цвет), которые нужно добавить в стек.
      -- Получаем их из всех смежных данной вершине графа вершин, оставляя только те из
      -- них, которые мы ещё не обошли или цвет которых совпадает совпадает с текущим
      -- цветом на вершине стека.
      --
      -- NB! Таким образом в списке newNodes могут быть вершины, которые уже были
      -- покрашены в цвет, совпадающий с цветом обрабатываемой вершины.
      newNodes = map (\x -> (x, not color)) $ filter filterFun $ adjacentNodes node graph
      -- Проверяем что на стеке нет вершин, ранее покрашеных в цвет, совпадающий с
      -- цветом обрабатываемой вершины
      newNodesAreOk = all stackNodeIsOk newNodes
      -- Новый стек получаем конкатенацией новых вершин и хвоста текущего стека
      newStack = newNodes ++ tail stack
      -- Нам необходимо добавить обрабатываемую вершину к соответствующему множеству
      -- цветов
      newRed = if color then node: redSet else redSet
      newBlue = if not color then node: blueSet else blueSet
      -- Проверяет, что пара (вершина, цвет) не конфликтует с текущей раскраской графа
      stackNodeIsOk (x, color) = if color then not (x `elem` blueSet) else not (x `elem` redSet)
      -- Вспомогательная функция, использующаяся для того чтобы отфильтровать только
      -- те смежные вершины, которые мы ещё не обошли или те, которые конфликтуют с
      -- текущей раскраской графа
      filterFun x = if color then not (x `elem` blueSet) else not (x `elem` redSet)

bigraph :: Graph -> Bool
bigraph (0, _) = True
bigraph graph@(n, edgeTest) = dfsBipartite [] [] graph [(1, True)]

-- Входные данные для тестов
testInput = [
  -- Графы с 0, 1 и 2 вершинами всегда двудольные.
  (0, \x y -> x /= y),
  (1, \x y -> x /= y),
  (2, \x y -> x /= y),
  -- Полный граф на трёх вершинах(треугольник) не является двудольным.
  -- (Содержит цикл нечётной длины)
  (3, \x y -> x /= y),
  -- Полный граф на >=3 вершинах никогда не будет двудольным.
  (500, \x y -> x /= y),
  -- Некоторое дерево на 50 вершинах, является двудольным(как и любое дерево)
  (50, \x y -> x == y + 1 || y == x + 1)
  ]

-- Ожидаемые результаты тестов
results = [
  True,
  True,
  True,
  False,
  False,
  True
  ]

-- True, если тесты пройдены
-- False, иначе
test = results == map bigraph testInput

-- Список из результатов каждого теста по отдельности
testDetail = zipWith (==) results $ map bigraph testInput
