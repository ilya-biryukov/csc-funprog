{-- Домашнее задание № 5. Задача 2. Бирюков Илья, CS Center, отделение SE
 -
 - Найти все способы разбиения заданной строки символов на слова из заданного словаря
 - или определить, что такого разбиения не существует. Функция должна получать в
 - качестве аргументов исходную строку и список попарно несовпадающих слов (словарь),
 - а в результате выдавать список возможных разбиений (каждое разбиение — это список
 - слов из словаря, при соединении которых получается исходная строка).
 - Например, для исходной строки
 -   "to be or not to be"
 - и словаря
 -   [" ", "a", "be", "is", "or", "one", "not", "that", "to"]
 - результатом должен быть список, содержащий единственное разбиение:
 -  [["to", " ", "be", " ", "or", " ", "not", " ", "to", " ", "be"]].
 - Если вариантов разбиения исходной строки нет, функция должна выдавать разумный
 - результат, например, пустой список.
 -}

import Data.List(isPrefixOf, sort)

{--
 -  Выдаёт все возможные разбиения строки на слова из словаря.
 -  Если такое разбиение невозможно, то выдаёт пустой список.
 -
 -  Аргументы:
 -      str Строка, которую необходимо разбить
 -      dict Словарь - список из строк, в котором никакая строка не должна
 -        встречаться дважды, чтобы не получить лишних возможных разбиений
 -
 -  Возвращает:
 -      Список, содержащий все возможные разбиения переданной строки на слова из словаря
 -}
-- Если строка пустая удобно вернуть пустой список в качестве единственного
-- возможного разбиения.
dictSplits "" _ = [[]]
-- План такой:
-- 1) находим все слова в словаре, на которые начинается наша строка.
-- 2) рекурсивно вызываемся для каждого из слов, полученных в пункте 1, удаляя это слово
--    с начала строки.
-- 3) добавляем полученное слово первым элементов ко всем спискам(разбиениям),
--    полученным в пунтке 2
-- 4) конкатенируем все разбиения, полученные в пунтках 2-3
dictSplits str dict = concat $ map addWord startWords
    where
    addWord w = map (w:) $ dictSplits (drop (length w) str) dict
    startWords = filter (`isPrefixOf` str) dict

-- Входные данные для тестов
testInput = [
  -- Пример из задания. Проверяет возможность разбиения с лишними словами в словаре.
  ("to be or not to be", [" ", "a", "be", "is", "or", "one", "not", "that", "to"]),
  -- Разбиения не существует, проблема в конце строки(последний символ)
  ("to be or not to be#", [" ", "a", "be", "is", "or", "one", "not", "that", "to"]),
  -- Разбиения не существует, проблема в середине строки(нет пробела)
  ("A lion", ["A", "lion"]),
  -- Существует несколько разбиений
  ("bow,and,arrows", ["bow", "arrows", "and", "bow,and", "and,arrows", ","]),
  -- Пустая строка
  ("", ["a", "b", "c"]),
  -- Пустой словарь, разбиений не найдётся
  ("bow and arrows", [])
  ]


-- Ожидаемые результаты тестов(сортируем чтобы порядок не имел значения)
results = map sort [
  [["to", " ", "be", " ", "or", " ", "not", " ", "to", " ", "be"]],
  [],
  [],
  [ ["bow", ",", "and", ",", "arrows"], ["bow,and", ",", "arrows"],
    ["bow", ",", "and,arrows"]],
  [[]],
  []
  ]


-- Результат тестов(сортировка нужна чтобы порядок не имел значения)
test = results == map (sort . (uncurry dictSplits)) testInput

-- Более детеальная информация по каждому из тестов
testDetail = zipWith (==) results $ map (sort . (uncurry dictSplits)) testInput
