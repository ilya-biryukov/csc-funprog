{-- Домашнее задание № 5. Задача 1. Бирюков Илья, CS Center, отделение SE
 -
 - Определить, можно ли расставить знаки "+", "-", "*" и круглые скобки между числами
 - 1, 2,..., 10 (именно в этом порядке, без перестановок) так, чтобы в результате
 - выполнения всех действий получилось заданное число. Функция должна получать на вход
 - число и выдавать строку, изображающую правильную расстановку знаков и скобок,
 - или строку "impossible", если заданное число получить невозможно.
 -
 - Например, для числа 2011 возможный вариант мог бы выглядеть так:
 - (1+((2*3)+(4+(5*((6*((7*8)+9))+10)))))
 - (конечно, в этой записи некоторые скобки - лишние).
 -}

-- Оператор
data Operator = Plus | Minus | Mult deriving (Eq, Show)
-- Элемент обратной польской записи - оператор или операнд
data RpnItem = OperatorItem Operator | OperandItem Integer deriving (Eq, Show)

{--
 -  Вспомогательная функция. Генерирует все возможные выражения в обратной польской
 -  записи, состоящий из чисел [1..n](стоящих именно в таком порядке) и операторов
 -  Plus, Minus, Mult.
 -
 -  Аргументы:
 -    n - количество операндов в обратной польской записи
 -
 -  Возвращает:
 -    Список из всех возможных выражений в обратной польской записи, в которых
 -}
generateRpns :: Integer -> [[RpnItem]]
-- План такой:
-- 1) генерируем все возможные последовательности только с оператором +,
-- 2) генерируем все возможные последовательности из (n - 1) операторов
-- 3) подставляем каждую возможную последовательность операторов из пункта 2 на
--    соответствующие позиции операторов + в пункте 1.
generateRpns n = map (reverse . fst) $ filter (\(_, y) -> y == 0) (genPartialRpns n)
    where
    -- Генерирует все посл-ти с n операндами и <= n-1 операторами Plus.
    -- Сгенерированные последовательности получаются в обратном порядке.
    -- Возвращает список Tuple'ов вида:
    --    (посл-ть, сколько операторов надо добавить чтобы получилась корреткная запись
    --     в ОПН)
    genPartialRpns 1 = [([OperandItem 1], 0)]
    genPartialRpns n = addOpers $ map addItem prevRpns
        where
        prevRpns = genPartialRpns (n - 1)
        addItem (list, count) = (OperandItem n:list, count + 1)
    -- Добавляет к списку пар (посл-ть, сколько операторов надо добавить) всевозможные
    -- пары, которые можно получить корректным добавлением дополнительных операторов
    -- (чтобы ``сколько надо добавить`` оставалось >= 0)
    addOpers = foldl addOpers' []
        where
        -- Обрабатывает один элемент списка
        addOpers' res item@(list, 0) = item:res
        addOpers' res item@(list, opCount) = addOpers' (item:res) withPlus
            where
            withPlus = (OperatorItem Plus:list, opCount - 1)
    -- Генерирует все возможные списки из n операторов
    makeOpersList 0 = [[]]
    makeOpersList n = foldl makeOpersList' [] prevLists
        where
        prevLists = makeOpersList (n - 1)
        makeOpersList' res list = map (:list) allOperItems ++ res
        allOperItems = map OperatorItem [Plus, Minus, Mult]
    -- Принимает на вход последовательности в ОПН, у которых все операторы нули и сп


